<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bodangles: Bone to be Wild</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Creepster&family=Roboto:wght@400;700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            color: white;
            font-family: 'Roboto', sans-serif;
            user-select: none;
        }

        canvas {
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            padding: 20px;
            box-sizing: border-box;
        }

        #top-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }

        #hp-bar-container {
            width: 250px;
            height: 25px;
            background: #330000;
            border: 2px solid #550000;
            position: relative;
        }

        #hp-bar-fill {
            width: 100%;
            height: 100%;
            background: #ff0000;
            transition: width 0.2s;
        }

        #hp-text {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
        }

        #xp-bar-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 10px;
            background: #001133;
            z-index: 5;
        }

        #xp-bar-fill {
            width: 0%;
            height: 100%;
            background: #3388ff;
            box-shadow: 0 0 10px #3388ff;
            transition: width 0.2s;
        }

        #level-indicator {
            position: absolute;
            top: 45px;
            /* Moved down slightly */
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Creepster', cursive;
            font-size: 2rem;
            color: #3388ff;
            text-shadow: 0 0 10px #000;
        }

        #timer-display {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Roboto', monospace;
            font-size: 2rem;
            font-weight: bold;
            color: #ccc;
            text-shadow: 0 0 5px #000;
        }

        #score-container {
            font-size: 1.5rem;
            font-weight: bold;
            text-align: right;
        }

        /* Modals */
        .modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            z-index: 20;
        }

        .modal.visible {
            display: flex;
        }

        .title-text {
            font-family: 'Creepster', cursive;
            font-size: 5rem;
            color: #e0e0e0;
            text-shadow: 0 0 20px #ffffff55;
            margin-bottom: 20px;
        }

        #upgrade-options {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .upgrade-card {
            background: #222;
            border: 2px solid #444;
            padding: 20px;
            width: 250px;
            text-align: center;
            cursor: pointer;
            transition: transform 0.2s, border-color 0.2s, background 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .upgrade-card:hover {
            transform: translateY(-10px);
            border-color: #ffd700;
            background: #333;
        }

        .upgrade-icon {
            font-size: 3rem;
            margin-bottom: 10px;
        }

        .upgrade-name {
            font-weight: bold;
            font-size: 1.2rem;
            color: #ffd700;
        }

        .upgrade-desc {
            font-size: 0.9rem;
            color: #ccc;
        }

        /* Slot Machine UI */
        #chest-screen {
            background: rgba(0, 0, 0, 0.95);
        }

        #slot-machine {
            width: 400px;
            height: 200px;
            background: #111;
            border: 10px solid #a83232;
            /* Red Chest Color */
            border-radius: 10px;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 50px #a83232aa;
        }

        #slot-strip {
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: transform 0.1s linear;
        }

        .slot-item {
            height: 200px;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            /* CRITICAL FIX: Prevent items from squishing */
            box-sizing: border-box;
            border-bottom: 1px solid #333;
            /* Visual guide */
        }

        #chest-message {
            margin-top: 30px;
            font-size: 2rem;
            font-family: 'Creepster', cursive;
            color: #ffd700;
            opacity: 0;
            transition: opacity 0.5s;
        }

        #chest-btn {
            margin-top: 20px;
            opacity: 0;
            pointer-events: none;
        }

        #chest-btn.visible {
            opacity: 1;
            pointer-events: auto;
        }

        /* Win Screen */
        #win-screen h1 {
            color: #44ff44;
            text-shadow: 0 0 20px #00ff00;
        }

        button {
            background: #e0e0e0;
            color: #111;
            border: none;
            padding: 15px 40px;
            font-size: 1.5rem;
            font-family: 'Creepster', cursive;
            cursor: pointer;
            transition: transform 0.1s, background 0.2s;
            border-radius: 4px;
            margin-top: 20px;
        }

        button:hover {
            background: #fff;
            transform: scale(1.05);
        }

        /* Mobile Controls */
        #mobile-controls {
            position: absolute;
            bottom: 50px;
            left: 50px;
            width: 150px;
            height: 150px;
            pointer-events: auto;
            /* Allow touch */
            display: none;
            /* Hidden by default, shown on touch */
        }

        @media (hover: none) and (pointer: coarse) {
            #mobile-controls {
                display: block;
            }
        }

        #joystick-base {
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            position: relative;
            touch-action: none;
        }

        #joystick-knob {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
        }
    </style>
</head>

<body>

    <canvas id="gameCanvas"></canvas>

    <!-- HUD -->
    <div id="xp-bar-container">
        <div id="xp-bar-fill"></div>
    </div>

    <div id="ui-layer">
        <div id="timer-display">00:00</div>

        <div id="top-bar">
            <!-- HP -->
            <div id="hp-bar-container">
                <div id="hp-bar-fill"></div>
                <div id="hp-text">100 / 100</div>
            </div>

            <!-- Level -->
            <div id="level-indicator">LVL 1</div>

            <!-- Score -->
            <div id="score-container">
                Score: <span id="score">0</span>
            </div>
        </div>

        <!-- Mobile Joystick -->
        <div id="mobile-controls">
            <div id="joystick-base">
                <div id="joystick-knob"></div>
            </div>
        </div>
    </div>

    <!-- Level Up Screen -->
    <div id="level-up-modal" class="modal">
        <div class="title-text" style="color: #ffd700;">LEVEL UP!</div>
        <div id="upgrade-options">
            <!-- Cards injected by JS -->
        </div>
    </div>

    <!-- Chest Screen -->
    <div id="chest-screen" class="modal">
        <div class="title-text" style="color: #ff3333;">TREASURE!</div>
        <div id="slot-machine">
            <div id="slot-strip">
                <!-- Items injected -->
            </div>
        </div>
        <div id="chest-message">Jackpot!</div>
        <button id="chest-btn">Claim</button>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-modal" class="modal">
        <div class="title-text" style="color: #ff3333;">YOU DIED</div>
        <p style="font-size: 1.5rem;">Survived: <span id="time-survived">0s</span></p>
        <p style="font-size: 1.5rem;">Score: <span id="final-score">0</span></p>
        <button id="restart-btn">Resurrect</button>
    </div>

    <!-- Victory Screen -->
    <div id="win-screen" class="modal">
        <div class="title-text" style="color: #00ff00;">VICTORY!</div>
        <p style="font-size: 1.5rem;">You survived the graveyard shift.</p>
        <div style="display: flex; gap: 20px;">
            <button id="win-restart-btn">Replay</button>
            <button id="win-continue-btn">Endless Mode</button>
        </div>
    </div>

    <!-- Main Menu -->
    <div id="main-menu" class="modal visible"
        style="background: url('https://upload.wikimedia.org/wikipedia/commons/2/27/Black_Screen.jpg') no-repeat center center; background-size: cover; background-color: #000; z-index: 2000;">
        <div class="title-text"
            style="color: #ffffff; text-shadow: 0 0 20px #aa0000; font-size: 6rem; margin-bottom: 0;">BODANGLES</div>
        <div style="font-family: 'Creepster', cursive; font-size: 2rem; color: #cc4444; margin-bottom: 50px;">BONE TO BE
            WILD <span style="font-size: 1rem; color: #666;">(v1.1 Fixed)</span></div>
        <button id="new-game-btn"
            style="font-size: 2.5rem; padding: 20px 60px; border: 4px solid #aa0000; color: #aa0000; background: #000;">NEW
            GAME</button>
    </div>

    <script>
        /**
         * BODANGLES: BONE TO BE WILD - Phase 3 (Chests & Loop)
         */

        // --- Config ---
        const CONFIG = {
            GRID_SIZE: 100,
            GAME_DURATION: 15 * 60, // 15 mins
            COLORS: {
                BG: '#080808',
                GRID: '#1a2e1a',
                PLAYER: '#f0f0f0',
                PROJECTILE: '#ffffaa',
                GEM_XP: '#3388ff',
                CHEST: '#ff3333',
                DAMAGE_TEXT: '#ffffff'
            }
        };

        // --- Definitions ---
        const UPGRADES = [
            { id: 'multishot', name: "Bone Split", icon: "ðŸ¦´", desc: "+1 Projectile", type: 'stat', stat: 'projectileCount', value: 1, weight: 10 },
            { id: 'rate', name: "Grave Haste", icon: "âš¡", desc: "+15% Fire Rate", type: 'stat', stat: 'fireRate', value: 0.15, mult: true, weight: 12 },
            { id: 'speed', name: "Ghost Step", icon: "ðŸ‘»", desc: "+15% Move Speed", type: 'stat', stat: 'speed', value: 0.15, mult: true, weight: 10 },
            { id: 'damage', name: "Calcium Boost", icon: "ðŸ’ª", desc: "+20% Damage", type: 'stat', stat: 'damage', value: 0.2, mult: true, weight: 0 }, // Removed (weight 0)
            { id: 'range', name: "Spectral Reach", icon: "ðŸŽ¯", desc: "+20% Range", type: 'stat', stat: 'range', value: 0.2, mult: true, weight: 10 },
            { id: 'health', name: "Marrow Shield", icon: "â¤ï¸", desc: "+25 Max HP & Heal", type: 'heal', value: 25, weight: 8 },
            { id: 'pickup', name: "Vacuum Ribs", icon: "ðŸ§²", desc: "+30% Pickup Range", type: 'stat', stat: 'pickupRange', value: 0.3, mult: true, weight: 8 },
            // New Weapons
            { id: 'femur', name: "Femur Club", icon: "ðŸ–", desc: "Melee Swing Attack", type: 'weapon', weaponClass: 'FemurClubWeapon', weight: 5 },
            { id: 'ribcage', name: "Rib Cage", icon: "ðŸ©»", desc: "Damaging Aura", type: 'weapon', weaponClass: 'RibCageWeapon', weight: 5 },
            { id: 'skullbomb', name: "Skull Bomb", icon: "ðŸ’£", desc: "Explosive Projectile", type: 'weapon', weaponClass: 'SkullBombWeapon', weight: 5 },
            { id: 'spine', name: "Spine Whip", icon: "ðŸ", desc: "Directional Lash", type: 'weapon', weaponClass: 'SpineWhipWeapon', weight: 5 },
            { id: 'tombstone', name: "Tombstone Drop", icon: "ðŸª¦", desc: "Crush from Above", type: 'weapon', weaponClass: 'TombstoneWeapon', weight: 5 }
        ];

        const ENEMY_TYPES = {
            ZOMBIE: { name: 'Zombie', color: '#cc4444', hp: 15, speed: 80, size: 25, xp: 10, weight: 1 },
            BAT: { name: 'Bat', color: '#7733cc', hp: 8, speed: 150, size: 20, xp: 5, weight: 0.5 },
            TANK: { name: 'Grave Guard', color: '#335533', hp: 60, speed: 50, size: 40, xp: 30, weight: 2 },
            // Bosses
            BOSS_1: { name: 'The Undertaker', color: '#994400', hp: 1500, speed: 90, size: 80, xp: 1000, boss: true },
            BOSS_2: { name: 'Bone Golem', color: '#888888', hp: 4000, speed: 70, size: 100, xp: 2000, boss: true },
            BOSS_FINAL: { name: 'Grim Reaper', color: '#440044', hp: 10000, speed: 110, size: 120, xp: 5000, boss: true }
        };

        // --- Input ---
        class InputHandler {
            constructor() {
                this.keys = {};
                window.addEventListener('keydown', e => this.keys[e.code] = true);
                window.addEventListener('keyup', e => this.keys[e.code] = false);

                // Touch Joystick
                this.touchId = null;
                this.stickX = 0;
                this.stickY = 0;
                this.baseEl = document.getElementById('joystick-base');
                this.knobEl = document.getElementById('joystick-knob');

                this.baseEl.addEventListener('touchstart', e => this.handleTouchStart(e), { passive: false });
                this.baseEl.addEventListener('touchmove', e => this.handleTouchMove(e), { passive: false });
                this.baseEl.addEventListener('touchend', e => this.handleTouchEnd(e));

                // Show joystick if touch detected anywhere
                window.addEventListener('touchstart', () => {
                    document.getElementById('mobile-controls').style.display = 'block';
                }, { once: true });
            }

            handleTouchStart(e) {
                e.preventDefault();
                const touch = e.changedTouches[0];
                this.touchId = touch.identifier;
                this.updateJoystick(touch.clientX, touch.clientY);
            }

            handleTouchMove(e) {
                e.preventDefault();
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === this.touchId) {
                        this.updateJoystick(e.changedTouches[i].clientX, e.changedTouches[i].clientY);
                        break;
                    }
                }
            }

            handleTouchEnd(e) {
                e.preventDefault();
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === this.touchId) {
                        this.touchId = null;
                        this.stickX = 0;
                        this.stickY = 0;
                        this.knobEl.style.transform = `translate(-50%, -50%)`;
                        break;
                    }
                }
            }

            updateJoystick(clientX, clientY) {
                const rect = this.baseEl.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;

                let dx = clientX - centerX;
                let dy = clientY - centerY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const maxDist = rect.width / 2 - 25; // 25 is knob radius

                if (dist > maxDist) {
                    dx = (dx / dist) * maxDist;
                    dy = (dy / dist) * maxDist;
                }

                // Normalize -1 to 1
                this.stickX = dx / maxDist;
                this.stickY = dy / maxDist;

                this.knobEl.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
            }

            isDown(...codes) { return codes.some(c => this.keys[c]); }

            getVector() {
                let x = 0, y = 0;
                // Keyboard
                if (this.isDown('ArrowUp', 'KeyW')) y -= 1;
                if (this.isDown('ArrowDown', 'KeyS')) y += 1;
                if (this.isDown('ArrowLeft', 'KeyA')) x -= 1;
                if (this.isDown('ArrowRight', 'KeyD')) x += 1;

                // Touch
                if (x === 0 && y === 0) {
                    x = this.stickX;
                    y = this.stickY;
                }

                // Normalize keyboard only if significant
                if (Math.abs(x) > 0.1 || Math.abs(y) > 0.1) {
                    // Only normalize if using keyboard discrete inputs (length > 1)
                    // If joystick, it's already circular, but clamping to 1 is good
                    const len = Math.sqrt(x * x + y * y);
                    if (len > 1) {
                        x /= len; y /= len;
                    }
                } else {
                    x = 0; y = 0;
                }

                return { x, y };
            }
        }

        // --- Entities ---
        class Entity {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.markedForDeletion = false;
                this.id = Math.random().toString(36).substr(2, 9);
            }
            update(dt) { }
            draw(ctx, sx, sy) { }
        }

        class Particle extends Entity {
            constructor(x, y, color) {
                super(x, y);
                this.color = color;
                const a = Math.random() * Math.PI * 2;
                const s = Math.random() * 100 + 50;
                this.vx = Math.cos(a) * s;
                this.vy = Math.sin(a) * s;
                this.life = 0.8;
            }
            update(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.life -= dt;
                if (this.life <= 0) this.markedForDeletion = true;
            }
            draw(ctx, sx, sy) {
                ctx.fillStyle = this.color;
                ctx.globalAlpha = this.life;
                ctx.fillRect(this.x - sx, this.y - sy, 4, 4);
                ctx.globalAlpha = 1.0;
            }
        }

        class FloatingText extends Entity {
            constructor(x, y, text, color) {
                super(x, y);
                this.text = text;
                this.color = color;
                this.life = 1.0;
                this.vy = -30;
            }
            update(dt) {
                this.y += this.vy * dt;
                this.life -= dt;
                if (this.life <= 0) this.markedForDeletion = true;
            }
            draw(ctx, sx, sy) {
                ctx.fillStyle = this.color;
                ctx.font = `bold 16px Arial`;
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillText(this.text, this.x - sx, this.y - sy);
                ctx.globalAlpha = 1.0;
            }
        }

        class Chest extends Entity {
            constructor(x, y) {
                super(x, y);
                this.size = 40;
                this.color = '#a83232';
                this.glow = 0;
            }
            update(dt) {
                this.glow += dt * 5;
            }
            draw(ctx, sx, sy) {
                const cx = this.x - sx;
                const cy = this.y - sy;

                ctx.fillStyle = this.color;
                ctx.shadowColor = '#ffaa00';
                ctx.shadowBlur = 10 + Math.sin(this.glow) * 5;
                ctx.fillRect(cx - this.size / 2, cy - this.size / 2, this.size, this.size);

                // Gold trim
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 4;
                ctx.strokeRect(cx - this.size / 2, cy - this.size / 2, this.size, this.size);
                ctx.shadowBlur = 0;
            }
        }

        class Gem extends Entity {
            constructor(x, y, xpValue) {
                super(x, y);
                this.xpValue = xpValue;
                this.magnetized = false;
                this.speed = 400;
                this.startLife = 60;
            }
            update(dt, player) {
                if (this.startLife > 0) this.startLife -= dt;
                if (this.startLife <= 0 && !this.magnetized) { this.markedForDeletion = true; return; }

                if (this.magnetized) {
                    const dx = player.x - this.x;
                    const dy = player.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 10) return;

                    this.x += (dx / dist) * this.speed * dt;
                    this.y += (dy / dist) * this.speed * dt;
                    this.speed += 10 * dt;
                } else {
                    const dx = player.x - this.x;
                    const dy = player.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < player.stats.pickupRange) this.magnetized = true;
                }
            }
            draw(ctx, sx, sy) {
                ctx.fillStyle = CONFIG.COLORS.GEM_XP;
                const s = 6;
                ctx.beginPath();
                ctx.moveTo(this.x - sx, this.y - sy - s);
                ctx.lineTo(this.x - sx + s, this.y - sy);
                ctx.lineTo(this.x - sx, this.y - sy + s);
                ctx.lineTo(this.x - sx - s, this.y - sy);
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }

        class Projectile extends Entity {
            constructor(x, y, vx, vy, damage, duration, source) {
                super(x, y);
                this.vx = vx;
                this.vy = vy;
                this.damage = damage;
                this.life = duration;
                this.rotation = 0;
            }
            update(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.rotation += 15 * dt;
                this.life -= dt;
                if (this.life <= 0) this.markedForDeletion = true;
            }
            draw(ctx, sx, sy) {
                ctx.save();
                ctx.translate(this.x - sx, this.y - sy);
                ctx.rotate(this.rotation);

                if (this.isMelee) {
                    // Draw Big Bone Club
                    ctx.fillStyle = '#fff';
                    ctx.shadowColor = '#000';
                    ctx.shadowBlur = 5;
                    ctx.beginPath();
                    // Handle
                    ctx.fillRect(0, -5, 40, 10);
                    // Knobs
                    ctx.arc(45, -5, 8, 0, Math.PI * 2);
                    ctx.arc(45, 5, 8, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.isBomb) {
                    // Draw Skull Bomb
                    ctx.fillStyle = '#eee';
                    ctx.beginPath();
                    ctx.arc(0, 0, 8, 0, Math.PI * 2);
                    ctx.fill();
                    // Fuse
                    ctx.strokeStyle = '#f00';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(0, -8);
                    ctx.quadraticCurveTo(5, -15, 10, -10);
                    ctx.stroke();
                    // Spark
                    if (Math.random() > 0.5) {
                        ctx.fillStyle = '#ff0';
                        ctx.fillRect(10, -12, 4, 4);
                    }
                } else {
                    // Normal Bone Shard
                    // Glow
                    ctx.shadowColor = CONFIG.COLORS.PROJECTILE;
                    ctx.shadowBlur = 10;

                    // Bone Shape
                    ctx.fillStyle = '#ffffe0';
                    ctx.beginPath();
                    ctx.moveTo(0, -10);
                    ctx.lineTo(3, -5);
                    ctx.lineTo(3, 5);
                    ctx.lineTo(0, 10);
                    ctx.lineTo(-3, 5);
                    ctx.lineTo(-3, -5);
                    ctx.closePath();
                    ctx.fill();
                }

                ctx.shadowBlur = 0;
                ctx.restore();
            }
        }

        class Explosion extends Entity {
            constructor(x, y, damage, radius) {
                super(x, y);
                this.damage = damage;
                this.radius = radius;
                this.life = 0.5; // Visual duration
                this.maxLife = 0.5;
                this.hitDealt = false;
            }

            update(dt, game) {
                this.life -= dt;
                if (this.life <= 0) this.markedForDeletion = true;

                if (!this.hitDealt) {
                    this.hitDealt = true;
                    const rSq = this.radius * this.radius;
                    game.enemies.forEach(e => {
                        const d = (e.x - this.x) ** 2 + (e.y - this.y) ** 2;
                        if (d < rSq) {
                            e.takeDamage(this.damage, game);
                        }
                    });
                }
            }

            draw(ctx, sx, sy) {
                const cx = this.x - sx;
                const cy = this.y - sy;
                const progress = 1 - (this.life / this.maxLife);

                // Shockwave Ring
                ctx.strokeStyle = `rgba(255, 200, 50, ${1 - progress})`;
                ctx.lineWidth = 15 * (1 - progress);
                ctx.beginPath();
                ctx.arc(cx, cy, this.radius * progress, 0, Math.PI * 2);
                ctx.stroke();

                // Core flash (fades out fast)
                if (progress < 0.3) {
                    ctx.fillStyle = `rgba(255, 255, 255, ${1 - (progress / 0.3)})`;
                    ctx.beginPath();
                    ctx.arc(cx, cy, this.radius * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Smoke/Fire inner
                ctx.fillStyle = `rgba(255, 50, 0, ${(1 - progress) * 0.5})`;
                ctx.beginPath();
                ctx.arc(cx, cy, this.radius * 0.8 * progress, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class MeleeSwing extends Entity {
            constructor(owner, angle, duration, damage, knockback) {
                super(owner.x, owner.y);
                this.owner = owner;
                this.startAngle = angle - 1.5; // Start 90 deg back
                this.endAngle = angle + 1.5;   // End 90 deg forward
                this.currentAngle = this.startAngle;
                this.duration = duration;
                this.maxDuration = duration;
                this.damage = damage;
                this.knockback = knockback;
                this.size = 60; // For hitbox
                this.hitList = []; // Enemies already hit
            }

            update(dt, game) {
                this.duration -= dt;
                if (this.duration <= 0) this.markedForDeletion = true;

                // Stick to owner
                this.x = this.owner.x;
                this.y = this.owner.y;

                // Rotate
                const p = 1 - (this.duration / this.maxDuration); // 0 to 1
                // Easing? Linear for now
                this.currentAngle = this.startAngle + (this.endAngle - this.startAngle) * p;

                // Hitbox logic (Arc check is hard, let's just checking circle at tip of club)
                const tipDist = 60;
                const tipX = this.x + Math.cos(this.currentAngle) * tipDist;
                const tipY = this.y + Math.sin(this.currentAngle) * tipDist;

                // Check collisions
                // We'll be generous and check a few points along the arm if needed, or just a big circle at the tip
                // Let's check circle at tip + mid
                const checkPoints = [
                    { x: tipX, y: tipY, r: 40 },
                    { x: this.x + Math.cos(this.currentAngle) * 30, y: this.y + Math.sin(this.currentAngle) * 30, r: 20 }
                ];

                game.enemies.forEach(e => {
                    if (this.hitList.includes(e.id)) return; // Don't hit twice per swing

                    let hit = false;
                    for (const cp of checkPoints) {
                        const d = (e.x - cp.x) ** 2 + (e.y - cp.y) ** 2;
                        if (d < (cp.r + e.size) ** 2) {
                            hit = true;
                            break;
                        }
                    }

                    if (hit) {
                        e.takeDamage(this.damage, game);
                        // Knockback
                        const kbAngle = Math.atan2(e.y - this.y, e.x - this.x);
                        e.x += Math.cos(kbAngle) * this.knockback * dt * 5; // Simplified kb push
                        e.y += Math.sin(kbAngle) * this.knockback * dt * 5;
                        this.hitList.push(e.id);
                    }
                });
            }

            draw(ctx, sx, sy) {
                const cx = this.x - sx;
                const cy = this.y - sy;

                ctx.save();
                ctx.translate(cx, cy);
                ctx.rotate(this.currentAngle);

                // Draw Club
                // Handle
                ctx.fillStyle = '#ddd';
                ctx.shadowColor = '#000';
                ctx.shadowBlur = 5;
                ctx.beginPath();
                ctx.fillRect(0, -5, 80, 10);

                // Big Bone End
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(80, -8, 12, 0, Math.PI * 2);
                ctx.arc(80, 8, 12, 0, Math.PI * 2);
                ctx.fill();

                // Swoosh trail
                ctx.shadowBlur = 0;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 20;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                // Draw arc behind? Maybe next time

                ctx.restore();
            }
        }

        class SpineWhip extends Entity {
            constructor(owner, angle, length, damage) {
                super(owner.x, owner.y);
                this.owner = owner;
                this.angle = angle;
                this.length = length;
                this.damage = damage;
                this.life = 0.2; // Quick lash
                this.hitList = [];
            }

            update(dt, game) {
                this.life -= dt;
                if (this.life <= 0) this.markedForDeletion = true;

                this.x = this.owner.x;
                this.y = this.owner.y;

                // Rectangular hitbox check along the line of the whip
                // Simplified: check points along the line
                const steps = 10;
                for (let i = 1; i <= steps; i++) {
                    const ld = (this.length / steps) * i;
                    const lx = this.x + Math.cos(this.angle) * ld;
                    const ly = this.y + Math.sin(this.angle) * ld;

                    game.enemies.forEach(e => {
                        if (this.hitList.includes(e.id)) return;
                        const d = (e.x - lx) ** 2 + (e.y - ly) ** 2;
                        if (d < (e.size + 20) ** 2) { // 20 radius whip thickness
                            e.takeDamage(this.damage, game);
                            this.hitList.push(e.id);
                        }
                    });
                }
            }

            draw(ctx, sx, sy) {
                const cx = this.x - sx;
                const cy = this.y - sy;

                ctx.save();
                ctx.translate(cx, cy);
                ctx.rotate(this.angle);

                // Draw Spine
                for (let i = 0; i < 10; i++) {
                    const x = (this.length / 10) * i;
                    ctx.fillStyle = '#eee';
                    ctx.beginPath();
                    ctx.fillRect(x, -5, (this.length / 10) - 2, 10);
                }

                ctx.restore();
            }
        }

        class Tombstone extends Entity {
            constructor(x, y, damage) {
                super(x, y - 500); // Start high up
                this.targetY = y;
                this.damage = damage;
                this.vy = 1000;
                this.landed = false;
                this.life = 1.0; // Stay for 1 sec after landing
            }

            update(dt, game) {
                if (!this.landed) {
                    this.y += this.vy * dt;
                    if (this.y >= this.targetY) {
                        this.y = this.targetY;
                        this.landed = true;
                        // Smash!
                        // Screenshake maybe?
                        const radius = 80;
                        game.enemies.forEach(e => {
                            const d = (e.x - this.x) ** 2 + (e.y - this.y) ** 2;
                            if (d < (radius + e.size) ** 2) {
                                e.takeDamage(this.damage * 2, game); // Massive crit on direct hit
                            }
                        }); // Also purely visual shockwave
                        game.particles.push(new Explosion(this.x, this.y, this.damage / 2, 120)); // Smaller damage wider area
                    }
                } else {
                    this.life -= dt;
                    if (this.life <= 0) this.markedForDeletion = true;
                }
            }

            draw(ctx, sx, sy) {
                const cx = this.x - sx;
                const cy = this.y - sy;

                // Shadow if in air
                if (!this.landed) {
                    const groundY = this.targetY - sy;
                    ctx.fillStyle = 'rgba(0,0,0,0.3)';
                    ctx.beginPath();
                    ctx.ellipse(cx, groundY, 40, 15, 0, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Tombstone
                ctx.fillStyle = '#555';
                ctx.fillRect(cx - 20, cy - 40, 40, 50);
                ctx.beginPath();
                ctx.arc(cx, cy - 40, 20, Math.PI, 0);
                ctx.fill();
                // RIP
                ctx.fillStyle = '#333';
                ctx.font = '10px monospace';
                ctx.fillText("R.I.P", cx - 12, cy - 20);
            }
        }

        class Enemy extends Entity {
            constructor(x, y, typeDef) {
                super(x, y);
                this.props = typeDef;
                this.hp = typeDef.hp;
                this.maxHp = typeDef.hp;
                this.speed = typeDef.speed;
                this.hitFlash = 0;
                this.isBoss = !!typeDef.boss;
            }
            takeDamage(amt, game) {
                this.hp -= amt;
                this.hitFlash = 0.1;
                if (this.hp <= 0 && !this.markedForDeletion) {
                    this.markedForDeletion = true;
                    if (game) {
                        game.player.gainXp(this.props.xp);
                        game.score += this.props.xp;
                        if (Math.random() < 0.01) game.chests.push(new Chest(this.x, this.y));
                        else if (Math.random() < 0.05) game.gems.push(new Gem(this.x, this.y, this.props.xp));
                    }
                    return true;
                }
                return false;
            }
            update(dt, player) {
                if (this.hitFlash > 0) this.hitFlash -= dt;

                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > 0) {
                    this.x += (dx / dist) * this.speed * dt;
                    this.y += (dy / dist) * this.speed * dt;
                }
            }
            draw(ctx, sx, sy) {
                const cx = this.x - sx;
                const cy = this.y - sy;
                const s = this.props.size;
                const name = this.props.name;

                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.4)';
                ctx.beginPath();
                ctx.ellipse(cx, cy + s / 2, s / 2, s / 5, 0, 0, Math.PI * 2);
                ctx.fill();

                if (this.hitFlash > 0) {
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(cx - s / 2, cy - s / 2, s, s);
                    return;
                }

                if (name === 'Bat') {
                    // Bat Wings
                    const wingOffset = Math.sin(Date.now() / 50) * 10;
                    ctx.fillStyle = this.props.color;
                    ctx.beginPath();
                    // Body
                    ctx.arc(cx, cy, s / 3, 0, Math.PI * 2);
                    // Wings
                    ctx.moveTo(cx - 5, cy);
                    ctx.quadraticCurveTo(cx - s, cy - 20 + wingOffset, cx - s - 10, cy + 10);
                    ctx.quadraticCurveTo(cx - s / 2, cy + 5, cx - 5, cy + 5);

                    ctx.moveTo(cx + 5, cy);
                    ctx.quadraticCurveTo(cx + s, cy - 20 + wingOffset, cx + s + 10, cy + 10);
                    ctx.quadraticCurveTo(cx + s / 2, cy + 5, cx + 5, cy + 5);
                    ctx.fill();

                    // Bat Eyes
                    ctx.fillStyle = '#ff0';
                    ctx.fillRect(cx - 3, cy - 2, 2, 2);
                    ctx.fillRect(cx + 1, cy - 2, 2, 2);

                } else if (name === 'Zombie' || name === 'Grave Guard') {
                    // Zombie Shape
                    const bob = Math.abs(Math.sin(Date.now() / 150)) * 5;
                    ctx.fillStyle = this.props.color;

                    // Head
                    ctx.beginPath();
                    ctx.arc(cx, cy - s / 3 - bob, s / 3, 0, Math.PI * 2);
                    ctx.fill();

                    // Body
                    ctx.fillRect(cx - s / 3, cy - bob, s / 1.5, s / 1.5);

                    // Arms (Outstretched)
                    ctx.fillRect(cx - s / 2, cy - bob, s, s / 5);

                    // Eyes
                    ctx.fillStyle = '#000';
                    ctx.fillRect(cx - 5, cy - s / 3 - bob - 2, 3, 3);
                    ctx.fillRect(cx + 2, cy - s / 3 - bob - 2, 3, 3);
                } else {
                    // Bosses/Generic
                    ctx.fillStyle = this.props.color;
                    ctx.fillRect(cx - s / 2, cy - s / 2, s, s);
                }

                // HP Bar (Universal)
                if (this.hp < this.maxHp) {
                    ctx.fillStyle = '#500';
                    ctx.fillRect(cx - s / 2, cy - s / 2 - 12, s, 4);
                    ctx.fillStyle = '#0f0';
                    ctx.fillRect(cx - s / 2, cy - s / 2 - 12, Math.max(0, s * (this.hp / this.maxHp)), 4);
                }
            }
        }

        class Player extends Entity {
            constructor(game, x, y) {
                super(x, y);
                this.game = game;
                this.vx = 0; this.vy = 0;
                this.size = 32;

                this.stats = {
                    maxHp: 100,
                    speed: 300,
                    fireRate: 1.0,
                    damage: 20,
                    projectileCount: 1,
                    range: 600,
                    pickupRange: 100
                };

                this.hp = this.stats.maxHp;
                this.xp = 0;
                this.level = 1;
                this.nextLevelXp = 20;

                this.invincibleTimer = 0;

                // Initialize Weapons
                this.weapons = [];
                this.weapons.push(new BoneShardWeapon(game, this));
            }

            gainXp(amount) {
                this.xp += amount;
                if (this.xp >= this.nextLevelXp) {
                    this.xp -= this.nextLevelXp;
                    this.level++;
                    this.nextLevelXp = Math.floor(this.nextLevelXp * 1.2 + 50);
                    return true;
                }
                return false;
            }

            takeDamage(amount) {
                if (this.invincibleTimer > 0) return false;
                this.hp -= amount;
                this.invincibleTimer = 0.5;
                return true;
            }

            heal(amount) {
                this.hp = Math.min(this.hp + amount, this.stats.maxHp);
            }

            update(dt, input) {
                const move = input.getVector();
                const targetVx = move.x * this.stats.speed;
                const targetVy = move.y * this.stats.speed;
                const accel = 15;

                this.vx += (targetVx - this.vx) * accel * dt;
                this.vy += (targetVy - this.vy) * accel * dt;
                this.x += this.vx * dt;
                this.y += this.vy * dt;

                if (this.invincibleTimer > 0) this.invincibleTimer -= dt;

                // Update Weapons
                this.weapons.forEach(w => w.update(dt));
            }

            draw(ctx, sx, sy) {
                if (this.invincibleTimer > 0 && Math.floor(Date.now() / 100) % 2 === 0) return;
                const cx = this.x - sx;
                const cy = this.y - sy;

                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.beginPath();
                ctx.ellipse(cx, cy + 15, 10, 4, 0, 0, Math.PI * 2);
                ctx.fill();

                // Body (Robes)
                ctx.fillStyle = '#222';
                ctx.beginPath();
                ctx.moveTo(cx, cy - 10);
                ctx.lineTo(cx + 12, cy + 15);
                ctx.lineTo(cx - 12, cy + 15);
                ctx.fill();

                // Skull Head
                ctx.fillStyle = '#eee';
                ctx.shadowColor = '#fff';
                ctx.shadowBlur = (this.invincibleTimer > 0) ? 0 : 5;
                ctx.beginPath();
                ctx.arc(cx, cy - 8, 10, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;

                // Eyes
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.arc(cx - 3, cy - 8, 2, 0, Math.PI * 2);
                ctx.arc(cx + 3, cy - 8, 2, 0, Math.PI * 2);
                ctx.fill();

                // Hands (Floating)
                const t = Date.now() / 200;
                ctx.fillStyle = '#eee';
                ctx.beginPath();
                ctx.arc(cx - 15, cy + Math.sin(t) * 3, 4, 0, Math.PI * 2);
                ctx.arc(cx + 15, cy + Math.cos(t) * 3, 4, 0, Math.PI * 2);
                ctx.fill();

                // Draw Weapons (e.g. Auras)
                this.weapons.forEach(w => w.draw(ctx, sx, sy));
            }
        }

        // --- Weapon System ---
        class Weapon {
            constructor(game, owner) {
                this.game = game;
                this.owner = owner;
                this.cooldownTimer = 0;
                this.level = 1;
                // Base stats, overridden by subclasses
                this.stats = {
                    cooldown: 1.0,
                    damage: 10,
                    count: 1,
                    speed: 100, // Speed of projectile if applicable
                    duration: 1, // Life of projectile
                    range: 200,
                    area: 1     // Scale multiplier
                };
            }

            // Apply modifiers from player stats or upgrades
            getStat(name) {
                let val = this.stats[name];
                // Apply player global multipliers if they exist in future
                // e.g. val *= this.owner.stats.globalDamageMult;
                return val;
            }

            update(dt) {
                if (this.cooldownTimer > 0) {
                    this.cooldownTimer -= dt;
                }
                if (this.cooldownTimer <= 0) {
                    this.fire();
                    // Reset cooldown, factoring in Fire Rate (higher rate = lower cooldown)
                    // We treat 'fireRate' stat as Attacks Per Second multiplier.
                    // Default cooldown is 1/fireRate if we used that, but here we use base cooldown / (1 + bonuses)
                    const rateMult = (this.owner.stats.fireRate || 1.0);
                    this.cooldownTimer = this.stats.cooldown / rateMult;
                }
            }

            fire() {
                // Override me
            }

            draw(ctx, sx, sy) {
                // Override me for auras or visible weapons
            }

            upgrade() {
                this.level++;
                // Check weapon-specific upgrade table
            }
        }

        // --- WEAPON IMPLEMENTATIONS ---

        class BoneShardWeapon extends Weapon {
            constructor(game, owner) {
                super(game, owner);
                this.stats = {
                    cooldown: 1.0, // Base 1s
                    damage: 20,
                    count: 1,
                    speed: 700,
                    duration: 1.5,
                    range: 600
                };
                this.name = "Bone Shard";
            }

            fire() {
                const pStats = this.owner.stats;
                const count = Math.floor(this.stats.count + (pStats.projectileCount - 1));
                // Use legacy stats for now
                const finalDmg = pStats.damage;

                // Target finding
                let targets = [];
                const rangeSq = pStats.range * pStats.range;
                for (const e of this.game.enemies) {
                    const d = (e.x - this.owner.x) ** 2 + (e.y - this.owner.y) ** 2;
                    if (d < rangeSq) targets.push({ e, d });
                }
                targets.sort((a, b) => a.d - b.d);
                if (targets.length === 0) return;

                const finalCount = Math.floor(pStats.projectileCount);
                for (let i = 0; i < finalCount; i++) {
                    const target = targets[i % targets.length].e;
                    let spread = (finalCount > 1) ? (i - (finalCount - 1) / 2) * 0.2 : 0;
                    const angle = Math.atan2(target.y - this.owner.y, target.x - this.owner.x) + spread;

                    const vx = Math.cos(angle) * this.stats.speed;
                    const vy = Math.sin(angle) * this.stats.speed;

                    this.game.projectiles.push(new Projectile(
                        this.owner.x, this.owner.y,
                        vx, vy,
                        finalDmg,
                        this.stats.duration
                    ));
                }
            }
        }

        class FemurClubWeapon extends Weapon {
            constructor(game, owner) {
                super(game, owner);
                this.stats = {
                    cooldown: 1.5,
                    damage: 35,
                    count: 1,
                    duration: 0.3,
                    range: 100, // Size of swing
                    knockback: 100
                };
                this.name = "Femur Club";
            }

            fire() {
                // Swing in facing direction
                // For simplicity, swing towards nearest enemy or movement direction
                // Default to movement
                let vx = this.owner.vx;
                let vy = this.owner.vy;
                if (Math.abs(vx) < 1 && Math.abs(vy) < 1) vx = 1; // Default right

                // If enemies nearby, aim at them
                let closeEnemies = this.game.enemies.filter(e => {
                    const d = (e.x - this.owner.x) ** 2 + (e.y - this.owner.y) ** 2;
                    return d < 40000; // 200px range
                });
                if (closeEnemies.length > 0) {
                    // Get closest
                    closeEnemies.sort((a, b) => ((a.x - this.owner.x) ** 2 + (a.y - this.owner.y) ** 2) - ((b.x - this.owner.x) ** 2 + (b.y - this.owner.y) ** 2));
                    let target = closeEnemies[0];
                    vx = target.x - this.owner.x;
                    vy = target.y - this.owner.y;
                }

                const angle = Math.atan2(vy, vx);

                // Spawn MeleeSwing attached to player
                this.game.particles.push(new MeleeSwing(
                    this.owner,
                    angle,
                    this.stats.duration,
                    this.stats.damage,
                    this.stats.knockback
                ));
            }
        }

        class RibCageWeapon extends Weapon {
            constructor(game, owner) {
                super(game, owner);
                this.stats = {
                    cooldown: 0.5, // Tick rate
                    damage: 5,
                    range: 120, // Radius
                    duration: 0 // Infinite
                };
                this.name = "Rib Cage";
                this.pulseTimer = 0;
            }

            update(dt) {
                // Rib Cage is always active, but deals damage on tick
                this.pulseTimer += dt;
                if (this.pulseTimer >= this.stats.cooldown) {
                    this.pulseTimer = 0;
                    // Deal damage
                    const rSq = this.stats.range * this.stats.range;
                    this.game.enemies.forEach(e => {
                        const d = (e.x - this.owner.x) ** 2 + (e.y - this.owner.y) ** 2;
                        if (d < rSq) {
                            e.takeDamage(this.stats.damage, this.game);
                        }
                    });
                }
            }

            draw(ctx, sx, sy) {
                const cx = this.owner.x - sx;
                const cy = this.owner.y - sy;

                // Periodic pulse effect
                const pulse = Math.sin(Date.now() / 200) * 5;

                ctx.strokeStyle = `rgba(255, 255, 255, 0.2)`;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(cx, cy, this.stats.range + pulse, 0, Math.PI * 2);
                ctx.stroke();

                // Rib bones
                ctx.strokeStyle = '#eee';
                ctx.lineWidth = 3;
                const r = this.stats.range + pulse;
                for (let i = 0; i < 6; i++) {
                    const a = (Date.now() / 1000) + (i * (Math.PI / 3));
                    ctx.beginPath();
                    ctx.arc(cx, cy, r, a, a + 0.5);
                    ctx.stroke();
                }
            }
        }

        class SkullBombWeapon extends Weapon {
            constructor(game, owner) {
                super(game, owner);
                this.stats = {
                    cooldown: 3.0,
                    damage: 50,
                    radius: 120, // Explosion size
                    speed: 400
                };
                this.name = "Skull Bomb";
            }

            fire() {
                let closest = null;
                let minDist = Infinity;
                for (const e of this.game.enemies) {
                    const d = (e.x - this.owner.x) ** 2 + (e.y - this.owner.y) ** 2;
                    if (d < minDist) { minDist = d; closest = e; }
                }

                let targetX = 0, targetY = 0;
                if (closest && minDist < 250000) { // 500 range
                    targetX = closest.x;
                    targetY = closest.y;
                } else {
                    // Random nearby
                    const angle = Math.random() * Math.PI * 2;
                    targetX = this.owner.x + Math.cos(angle) * 200;
                    targetY = this.owner.y + Math.sin(angle) * 200;
                }

                const angle = Math.atan2(targetY - this.owner.y, targetX - this.owner.x);
                const p = new Projectile(this.owner.x, this.owner.y, Math.cos(angle) * this.stats.speed, Math.sin(angle) * this.stats.speed, this.stats.damage, 1.0);
                p.isBomb = true;
                p.bombRadius = this.stats.radius;
                // Override update to explode
                p.update = (dt) => {
                    p.x += p.vx * dt;
                    p.y += p.vy * dt;
                    p.rotation += 10 * dt;
                    p.life -= dt;
                    if (p.life <= 0) {
                        p.markedForDeletion = true;
                        // Explode!
                        this.game.particles.push(new Explosion(p.x, p.y, p.damage, p.bombRadius));
                    }
                };
                this.game.projectiles.push(p);
            }
        }

        class SpineWhipWeapon extends Weapon {
            constructor(game, owner) {
                super(game, owner);
                this.stats = {
                    cooldown: 1.2,
                    damage: 30,
                    range: 200,   // Length
                };
                this.name = "Spine Whip";
            }

            fire() {
                // Lash in movement direction
                let vx = this.owner.vx;
                let vy = this.owner.vy;
                // If not moving, check enemies
                if (Math.abs(vx) < 1 && Math.abs(vy) < 1) {
                    let closest = null;
                    let minDist = Infinity;
                    for (const e of this.game.enemies) {
                        const d = (e.x - this.owner.x) ** 2 + (e.y - this.owner.y) ** 2;
                        if (d < minDist) { minDist = d; closest = e; }
                    }
                    if (closest && minDist < 160000) { // 400px
                        vx = closest.x - this.owner.x;
                        vy = closest.y - this.owner.y;
                    } else {
                        vx = 1; vy = 0; // Default right
                    }
                }

                const angle = Math.atan2(vy, vx);
                this.game.particles.push(new SpineWhip(this.owner, angle, this.stats.range, this.stats.damage));
            }
        }

        class TombstoneWeapon extends Weapon {
            constructor(game, owner) {
                super(game, owner);
                this.stats = {
                    cooldown: 4.0,
                    damage: 100,
                };
                this.name = "Tombstone Drop";
            }

            fire() {
                // Pick a random enemy to drop ON
                const targets = this.game.enemies.filter(e => {
                    const d = (e.x - this.owner.x) ** 2 + (e.y - this.owner.y) ** 2;
                    return d < 640000; // 800px range
                });

                let targetX = this.owner.x;
                let targetY = this.owner.y;

                if (targets.length > 0) {
                    const t = targets[Math.floor(Math.random() * targets.length)];
                    targetX = t.x;
                    targetY = t.y;
                } else {
                    // Random spot
                    targetX += (Math.random() - 0.5) * 400;
                    targetY += (Math.random() - 0.5) * 400;
                }

                this.game.particles.push(new Tombstone(targetX, targetY, this.stats.damage));
            }
        }

        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.resize();
                window.addEventListener('resize', () => this.resize());

                this.input = new InputHandler();

                // UI Refs
                this.elScore = document.getElementById('score');
                this.elHpFill = document.getElementById('hp-bar-fill');
                this.elHpText = document.getElementById('hp-text');
                this.elXpFill = document.getElementById('xp-bar-fill');
                this.elLevel = document.getElementById('level-indicator');
                this.elTimer = document.getElementById('timer-display');

                this.modalLevelUp = document.getElementById('level-up-modal');
                this.containerUpgrades = document.getElementById('upgrade-options');

                this.modalChest = document.getElementById('chest-screen');
                this.slotStrip = document.getElementById('slot-strip');
                this.chestMsg = document.getElementById('chest-message');
                this.chestBtn = document.getElementById('chest-btn');
                this.chestBtn.onclick = () => this.closeChest();

                this.modalGameOver = document.getElementById('game-over-modal');
                document.getElementById('restart-btn').onclick = () => this.reset();

                this.modalWin = document.getElementById('win-screen');
                document.getElementById('win-restart-btn').onclick = () => this.reset();
                document.getElementById('win-continue-btn').onclick = () => {
                    this.modalWin.classList.remove('visible');
                    this.isPaused = false;
                    this.endlessMode = true;
                };

                this.reset();
                this.loop = this.loop.bind(this);
                requestAnimationFrame(this.loop);
            }

            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            reset() {
                this.player = new Player(this, 0, 0);
                this.enemies = [];
                this.projectiles = [];
                this.particles = [];
                this.gems = [];
                this.chests = [];
                this.texts = [];

                this.score = 0;
                this.gameTime = 0;
                this.spawnRate = 0.5;
                this.spawnTimer = 0;

                this.bossesSpawned = { 1: false, 2: false, 3: false };
                this.endlessMode = false;

                this.isGameOver = false;
                this.isPaused = false;

                [this.modalGameOver, this.modalLevelUp, this.modalChest, this.modalWin].forEach(m => m.classList.remove('visible'));

                this.updateUI();
            }

            update(dt) {
                if (this.isPaused || this.isGameOver) return;

                this.gameTime += dt;

                // Timer UI
                const mins = Math.floor(this.gameTime / 60);
                const secs = Math.floor(this.gameTime % 60);
                this.elTimer.innerText = `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;

                // Win Condition
                if (!this.endlessMode && this.gameTime >= CONFIG.GAME_DURATION) {
                    this.winGame();
                    return; // Stop update
                }

                // Spawning
                this.spawnTimer -= dt;
                if (this.spawnTimer <= 0) {
                    this.spawnEnemy();
                    // Ramp
                    const progress = Math.min(1, this.gameTime / 600); // Max spawn rate at 10 mins
                    this.spawnRate = 0.5 - (0.4 * progress);
                    this.spawnTimer = this.spawnRate;
                }

                // Boss Checks
                this.checkBossSpawns();

                this.player.update(dt, this.input, this);
                this.projectiles.forEach(e => e.update(dt));
                this.enemies.forEach(e => e.update(dt, this.player));

                this.gems.forEach(e => e.update(dt, this.player));
                this.chests.forEach(e => e.update(dt));
                this.particles.forEach(e => e.update(dt, this));
                this.texts.forEach(e => e.update(dt));

                // Cleanup
                this.projectiles = this.projectiles.filter(e => !e.markedForDeletion);
                this.enemies = this.enemies.filter(e => !e.markedForDeletion);
                this.gems = this.gems.filter(e => !e.markedForDeletion);
                this.chests = this.chests.filter(e => !e.markedForDeletion);
                this.particles = this.particles.filter(e => !e.markedForDeletion);
                this.texts = this.texts.filter(e => !e.markedForDeletion);

                this.checkCollisions();
            }

            spawnEnemy() {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.max(this.canvas.width, this.canvas.height) / 2 + 100;
                const ex = this.player.x + Math.cos(angle) * dist;
                const ey = this.player.y + Math.sin(angle) * dist;

                // Wave Logic
                let pool = [ENEMY_TYPES.ZOMBIE];
                if (this.gameTime > 120) pool.push(ENEMY_TYPES.BAT); // 2m
                if (this.gameTime > 300) pool.push(ENEMY_TYPES.TANK); // 5m
                if (this.gameTime > 600) pool.push(ENEMY_TYPES.BAT); // More bats

                const type = pool[Math.floor(Math.random() * pool.length)];
                this.enemies.push(new Enemy(ex, ey, type));
            }

            checkBossSpawns() {
                const t = this.gameTime;
                if (!this.bossesSpawned[1] && t > 300) { // 5 mins
                    this.spawnBoss(ENEMY_TYPES.BOSS_1);
                    this.bossesSpawned[1] = true;
                }
                if (!this.bossesSpawned[2] && t > 600) { // 10 mins
                    this.spawnBoss(ENEMY_TYPES.BOSS_2);
                    this.bossesSpawned[2] = true;
                }
                if (!this.bossesSpawned[3] && t > 890) { // 14:50 (Final Boss)
                    this.spawnBoss(ENEMY_TYPES.BOSS_FINAL);
                    this.bossesSpawned[3] = true;
                }
            }

            spawnBoss(type) {
                const angle = Math.random() * Math.PI * 2;
                const dist = 500;
                this.enemies.push(new Enemy(this.player.x + Math.cos(angle) * dist, this.player.y + Math.sin(angle) * dist, type));
                this.addFloatingText("BOSS APPROACHING!", this.player.x, this.player.y - 100);
            }

            checkCollisions() {
                // Projectiles
                // Projectiles
                for (const p of this.projectiles) {
                    // Bombs handle themselves
                    if (p.isBomb) continue;

                    for (const e of this.enemies) {
                        if (p.markedForDeletion || e.markedForDeletion) continue;
                        // AABB Check
                        const hitDist = (e.props.size / 2) + 10;
                        if (Math.abs(p.x - e.x) < hitDist && Math.abs(p.y - e.y) < hitDist) {
                            e.takeDamage(p.damage, this);
                            // Handle pierce later? For now delete
                            if (!p.isMelee && !p.isBomb) p.markedForDeletion = true;
                            this.createParticles(e.x, e.y, e.props.color, 5);
                            this.addFloatingText(Math.round(p.damage), e.x, e.y - 20);
                        }
                    }
                }
                // Player Damaged
                for (const e of this.enemies) {
                    const d = Math.sqrt((e.x - this.player.x) ** 2 + (e.y - this.player.y) ** 2);
                    if (d < (this.player.size + e.props.size) / 2) {
                        if (this.player.takeDamage(10)) {
                            this.createParticles(this.player.x, this.player.y, '#f00', 8);
                            this.updateUI();
                            if (this.player.hp <= 0) this.gameOver();
                        }
                    }
                }
                // Gems
                for (const g of this.gems) {
                    if (g.markedForDeletion) continue;
                    const d = (g.x - this.player.x) ** 2 + (g.y - this.player.y) ** 2;
                    if (d < 900) {
                        g.markedForDeletion = true;
                        if (this.player.gainXp(g.xpValue)) this.showLevelUp();
                        this.updateUI();
                    }
                }
                // Chests
                for (const c of this.chests) {
                    if (c.markedForDeletion) continue;
                    const d = (c.x - this.player.x) ** 2 + (c.y - this.player.y) ** 2;
                    if (d < 1600) {
                        c.markedForDeletion = true;
                        this.openChest();
                    }
                }
            }

            // --- Events ---

            spawnGem(x, y, v) { this.gems.push(new Gem(x, y, v)); }
            createParticles(x, y, c, n) { for (let i = 0; i < n; i++) this.particles.push(new Particle(x, y, c)); }
            addFloatingText(t, x, y) { this.texts.push(new FloatingText(x, y, t, CONFIG.COLORS.DAMAGE_TEXT)); }

            updateUI() {
                this.elHpFill.style.width = Math.max(0, (this.player.hp / this.player.stats.maxHp) * 100) + '%';
                this.elHpText.innerText = `${Math.ceil(Math.max(0, this.player.hp))} / ${this.player.stats.maxHp}`;
                this.elXpFill.style.width = Math.max(0, (this.player.xp / this.player.nextLevelXp) * 100) + '%';
                this.elLevel.innerText = 'LVL ' + this.player.level;
                this.elScore.innerText = this.score;
            }

            gameOver() {
                this.isGameOver = true;
                this.modalGameOver.classList.add('visible');
            }

            winGame() {
                this.isPaused = true;
                this.modalWin.classList.add('visible');
            }

            showLevelUp() {
                this.isPaused = true;
                this.modalLevelUp.classList.add('visible');
                this.containerUpgrades.innerHTML = '';
                const opts = [];
                // Pool strategy for strict uniqueness
                const pool = [...UPGRADES];
                while (opts.length < 3 && pool.length > 0) {
                    let totalWeight = pool.reduce((a, b) => a + b.weight, 0);
                    let r = Math.random() * totalWeight;

                    let selectedIndex = -1;
                    for (let j = 0; j < pool.length; j++) {
                        if (r < pool[j].weight) {
                            selectedIndex = j;
                            break;
                        }
                        r -= pool[j].weight;
                    }

                    if (selectedIndex === -1) selectedIndex = 0;
                    opts.push(pool[selectedIndex]);
                    pool.splice(selectedIndex, 1);
                }

                console.log("Level Up Options Generated:", opts.map(o => o.name));

                opts.forEach(u => {
                    const c = document.createElement('div');
                    c.className = 'upgrade-card';
                    c.innerHTML = `<div class="upgrade-icon">${u.icon}</div><div class="upgrade-name">${u.name}</div><div class="upgrade-desc">${u.desc}</div>`;
                    c.onclick = () => {
                        this.applyUpgrade(u);
                        this.modalLevelUp.classList.remove('visible');
                        this.isPaused = false;
                    };
                    this.containerUpgrades.appendChild(c);
                });
            }

            getRandomUpgrade() {
                let t = UPGRADES.reduce((a, b) => a + b.weight, 0);
                let r = Math.random() * t;
                for (let u of UPGRADES) { if (r < u.weight) return u; r -= u.weight; }
                return UPGRADES[0];
            }

            applyUpgrade(u) {
                if (u.type === 'stat') {
                    if (u.mult) {
                        if (u.stat === 'projectileCount') this.player.stats[u.stat] += u.value;
                        else this.player.stats[u.stat] = Math.round(this.player.stats[u.stat] * (1 + u.value) * 100) / 100;
                    } else this.player.stats[u.stat] += u.value;
                } else if (u.type === 'heal') {
                    this.player.stats.maxHp += u.value;
                    this.player.heal(u.value);
                } else if (u.type === 'weapon') {
                    const existing = this.player.weapons.find(w => w.name === u.name);
                    if (existing) {
                        existing.upgrade();
                    } else {
                        // Instantiate by class name string
                        // We need a map or switch because eval is bad (though this is client side game)
                        // Better to use a switch or object map
                        switch (u.weaponClass) {
                            case 'FemurClubWeapon': this.player.weapons.push(new FemurClubWeapon(this, this.player)); break;
                            case 'RibCageWeapon': this.player.weapons.push(new RibCageWeapon(this, this.player)); break;
                            case 'SkullBombWeapon': this.player.weapons.push(new SkullBombWeapon(this, this.player)); break;
                            case 'BoneShardWeapon': this.player.weapons.push(new BoneShardWeapon(this, this.player)); break;
                            case 'SpineWhipWeapon': this.player.weapons.push(new SpineWhipWeapon(this, this.player)); break;
                            case 'TombstoneWeapon': this.player.weapons.push(new TombstoneWeapon(this, this.player)); break;
                        }
                    }
                }
            }

            // Chest Logic
            openChest() {
                this.isPaused = true;
                this.modalChest.classList.add('visible');
                this.chestBtn.classList.remove('visible');
                this.chestMsg.style.opacity = 0;

                // Slot Animation
                // Create strip of many items
                this.slotStrip.innerHTML = '';
                this.slotStrip.style.transition = 'none';
                this.slotStrip.style.transform = 'translateY(0)';
                this.slotStrip.innerHTML = '';

                const reward = this.getRandomUpgrade();
                this.pendingReward = reward;

                // Create the single display item
                const displayEl = document.createElement('div');
                displayEl.className = 'slot-item';
                this.slotStrip.appendChild(displayEl); // Ensure container centers this

                // Animation Params
                let count = 0;
                const maxSpins = 25; // number of flashes
                let currentDelay = 50; // starts fast (50ms)

                const nextSpin = () => {
                    setTimeout(() => {
                        count++;

                        if (count < maxSpins) {
                            // Show random item
                            const u = this.getRandomUpgrade();
                            displayEl.innerHTML = `<div style="font-size:5rem">${u.icon}</div><div style="font-size:2rem;color:#fff">${u.name}</div>`;

                            // Slow down logic: exponential decay of speed
                            if (count > 15) currentDelay *= 1.2;
                            nextSpin();
                        } else {
                            // STOP on REWARD (Final Logic)
                            displayEl.innerHTML = `<div style="font-size:6rem; text-shadow:0 0 30px #ffd700; animation: pop 0.5s ease-out forwards;">${reward.icon}</div><div style="font-size:2.5rem;color:#ffd700; animation: fadeUp 0.5s ease-out forwards;">${reward.name} (+ Power)</div>`;

                            setTimeout(() => {
                                this.chestMsg.innerText = `Mega ${reward.name}!`;
                                this.chestMsg.style.opacity = 1;
                                this.chestBtn.classList.add('visible');
                            }, 200);
                        }
                    }, currentDelay);
                };

                // Kickoff
                nextSpin();
            }

            closeChest() {
                // Apply reward 3x
                this.applyUpgrade(this.pendingReward);
                this.applyUpgrade(this.pendingReward);
                this.applyUpgrade(this.pendingReward);

                this.modalChest.classList.remove('visible');
                this.isPaused = false;
            }

            draw() {
                // Clear
                this.ctx.fillStyle = CONFIG.COLORS.BG;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                const sx = this.player.x - this.canvas.width / 2;
                const sy = this.player.y - this.canvas.height / 2;

                this.drawBackground(sx, sy);

                // Draw Entities
                // Layering: Gems -> Chests -> Particles -> Projectiles -> Enemies -> Player -> Text
                this.gems.forEach(e => e.draw(this.ctx, sx, sy));
                this.chests.forEach(e => e.draw(this.ctx, sx, sy));
                this.particles.forEach(e => e.draw(this.ctx, sx, sy));
                this.projectiles.forEach(e => e.draw(this.ctx, sx, sy));
                this.enemies.forEach(e => e.draw(this.ctx, sx, sy));
                this.player.draw(this.ctx, sx, sy);

                this.drawLighting();

                this.texts.forEach(e => e.draw(this.ctx, sx, sy));
            }

            drawBackground(sx, sy) {
                // Ground
                this.ctx.fillStyle = '#0a0a0a';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Grid (Faint)
                this.ctx.strokeStyle = '#1a1a1a';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();

                const sz = CONFIG.GRID_SIZE;
                const startX = Math.floor(sx / sz) * sz;
                const startY = Math.floor(sy / sz) * sz;

                for (let x = startX; x < sx + this.canvas.width + sz; x += sz) {
                    this.ctx.moveTo(x - sx, 0);
                    this.ctx.lineTo(x - sx, this.canvas.height);
                }
                for (let y = startY; y < sy + this.canvas.height + sz; y += sz) {
                    this.ctx.moveTo(0, y - sy);
                    this.ctx.lineTo(this.canvas.width, y - sy);
                }
                this.ctx.stroke();

                // Random details (Grass/Dirt patches)
                // Deterministic random using coordinates
                const patchSz = 200;
                const pStartX = Math.floor(sx / patchSz) * patchSz;
                const pStartY = Math.floor(sy / patchSz) * patchSz;

                this.ctx.fillStyle = '#111511';
                for (let x = pStartX; x < sx + this.canvas.width + patchSz; x += patchSz) {
                    for (let y = pStartY; y < sy + this.canvas.height + patchSz; y += patchSz) {
                        // Pseudo-random based on position
                        const r = Math.sin(x * 12.9898 + y * 78.233) * 43758.5453;
                        if ((r - Math.floor(r)) > 0.7) {
                            this.ctx.fillRect(x - sx + 10, y - sy + 10, patchSz - 20, patchSz - 20);
                        }
                    }
                }
            }

            drawLighting() {
                // Vignette
                const grad = this.ctx.createRadialGradient(
                    this.canvas.width / 2, this.canvas.height / 2, this.canvas.height / 3,
                    this.canvas.width / 2, this.canvas.height / 2, this.canvas.height
                );
                grad.addColorStop(0, 'rgba(0,0,0,0)');
                grad.addColorStop(1, 'rgba(0,0,0,0.8)');

                this.ctx.fillStyle = grad;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Color Overlay (night tint)
                this.ctx.fillStyle = 'rgba(0, 5, 20, 0.2)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            }

            loop(timestamp) {
                if (!this.lastTime) this.lastTime = timestamp;
                const dt = (timestamp - this.lastTime) / 1000;
                this.lastTime = timestamp;
                if (dt < 0.2) {
                    this.update(dt);
                    this.draw();
                }
                requestAnimationFrame(this.loop);
            }
        }

        window.onload = () => {
            const mainMenu = document.getElementById('main-menu');
            const newGameBtn = document.getElementById('new-game-btn');
            if (newGameBtn) {
                newGameBtn.onclick = () => {
                    mainMenu.classList.remove('visible');
                    try { window.game = new Game(); }
                    catch (e) { console.error(e); }
                };
            }
        };
    </script>
</body>

</html>